{"version":3,"file":"static/js/7764.js","mappings":"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","sources":["webpack://xxxxx/./node_modules/.pnpm/element-plus@2.3.7_vue@3.3.4/node_modules/element-plus/es/components/virtual-list/src/builders/build-grid.mjs","webpack://xxxxx/./node_modules/.pnpm/element-plus@2.3.7_vue@3.3.4/node_modules/element-plus/es/components/virtual-list/src/builders/build-list.mjs","webpack://xxxxx/./node_modules/.pnpm/element-plus@2.3.7_vue@3.3.4/node_modules/element-plus/es/components/virtual-list/src/components/dynamic-size-grid.mjs"],"sourcesContent":["import { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, h, resolveDynamicComponent } from 'vue';\nimport '../../../../utils/index.mjs';\nimport '../../../../hooks/index.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { useGridWheel } from '../hooks/use-grid-wheel.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport { virtualizedGridProps } from '../props.mjs';\nimport { isRTL, getRTLOffsetType, getScrollDir } from '../utils.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, FORWARD, BACKWARD, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, RTL, RTL_OFFSET_POS_ASC } from '../defaults.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { isNumber } from '../../../../utils/types.mjs';\nimport { getScrollBarWidth } from '../../../../utils/dom/scroll.mjs';\nimport { hasOwn, isString } from '@vue/shared';\nimport { isClient } from '@vueuse/core';\n\nconst createGrid = ({\n  name,\n  clearCache,\n  getColumnPosition,\n  getColumnStartIndexForOffset,\n  getColumnStopIndexForStartIndex,\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getColumnOffset,\n  getRowOffset,\n  getRowPosition,\n  getRowStartIndexForOffset,\n  getRowStopIndexForStartIndex,\n  initCache,\n  injectToInstance,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose, slots }) {\n      const ns = useNamespace(\"vl\");\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const cache = ref(initCache(props, instance));\n      injectToInstance == null ? void 0 : injectToInstance(instance, cache);\n      const windowRef = ref();\n      const hScrollbar = ref();\n      const vScrollbar = ref();\n      const innerRef = ref(null);\n      const states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      const getItemStyleCache = useCache();\n      const parsedHeight = computed(() => Number.parseInt(`${props.height}`, 10));\n      const parsedWidth = computed(() => Number.parseInt(`${props.width}`, 10));\n      const columnsToRender = computed(() => {\n        const { totalColumn, totalRow, columnCache } = props;\n        const { isScrolling, xAxisScrollDir, scrollLeft } = unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache));\n        const stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache));\n        const cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        const cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const rowsToRender = computed(() => {\n        const { totalColumn, totalRow, rowCache } = props;\n        const { isScrolling, yAxisScrollDir, scrollTop } = unref(states);\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache));\n        const stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache));\n        const cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        const cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalHeight = computed(() => getEstimatedTotalHeight(props, unref(cache)));\n      const estimatedTotalWidth = computed(() => getEstimatedTotalWidth(props, unref(cache)));\n      const windowStyle = computed(() => {\n        var _a;\n        return [\n          {\n            position: \"relative\",\n            overflow: \"hidden\",\n            WebkitOverflowScrolling: \"touch\",\n            willChange: \"transform\"\n          },\n          {\n            direction: props.direction,\n            height: isNumber(props.height) ? `${props.height}px` : props.height,\n            width: isNumber(props.width) ? `${props.width}px` : props.width\n          },\n          (_a = props.style) != null ? _a : {}\n        ];\n      });\n      const innerStyle = computed(() => {\n        const width = `${unref(estimatedTotalWidth)}px`;\n        const height = `${unref(estimatedTotalHeight)}px`;\n        return {\n          height,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width\n        };\n      });\n      const emitEvents = () => {\n        const { totalColumn, totalRow } = props;\n        if (totalColumn > 0 && totalRow > 0) {\n          const [\n            columnCacheStart,\n            columnCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd\n          ] = unref(columnsToRender);\n          const [rowCacheStart, rowCacheEnd, rowVisibleStart, rowVisibleEnd] = unref(rowsToRender);\n          emit(ITEM_RENDER_EVT, {\n            columnCacheStart,\n            columnCacheEnd,\n            rowCacheStart,\n            rowCacheEnd,\n            columnVisibleStart,\n            columnVisibleEnd,\n            rowVisibleStart,\n            rowVisibleEnd\n          });\n        }\n        const {\n          scrollLeft,\n          scrollTop,\n          updateRequested,\n          xAxisScrollDir,\n          yAxisScrollDir\n        } = unref(states);\n        emit(SCROLL_EVT, {\n          xAxisScrollDir,\n          scrollLeft,\n          yAxisScrollDir,\n          scrollTop,\n          updateRequested\n        });\n      };\n      const onScroll = (e) => {\n        const {\n          clientHeight,\n          clientWidth,\n          scrollHeight,\n          scrollLeft,\n          scrollTop,\n          scrollWidth\n        } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n        let _scrollLeft = scrollLeft;\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: true,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        };\n        nextTick(() => resetIsScrolling());\n        onUpdated();\n        emitEvents();\n      };\n      const onVerticalScroll = (distance, totalSteps) => {\n        const height = unref(parsedHeight);\n        const offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n      const onHorizontalScroll = (distance, totalSteps) => {\n        const width = unref(parsedWidth);\n        const offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n      const { onWheel } = useGridWheel({\n        atXStartEdge: computed(() => states.value.scrollLeft <= 0),\n        atXEndEdge: computed(() => states.value.scrollLeft >= estimatedTotalWidth.value - unref(parsedWidth)),\n        atYStartEdge: computed(() => states.value.scrollTop <= 0),\n        atYEndEdge: computed(() => states.value.scrollTop >= estimatedTotalHeight.value - unref(parsedHeight))\n      }, (x, y) => {\n        var _a, _b, _c, _d;\n        (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n        (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        scrollTo({\n          scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n          scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n        });\n      });\n      const scrollTo = ({\n        scrollLeft = states.value.scrollLeft,\n        scrollTop = states.value.scrollTop\n      }) => {\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n        const _states = unref(states);\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n        states.value = {\n          ..._states,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft,\n          scrollTop,\n          updateRequested: true\n        };\n        nextTick(() => resetIsScrolling());\n        onUpdated();\n        emitEvents();\n      };\n      const scrollToItem = (rowIndex = 0, columnIdx = 0, alignment = AUTO_ALIGNMENT) => {\n        const _states = unref(states);\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        const scrollBarWidth = getScrollBarWidth(ns.namespace.value);\n        const _cache = unref(cache);\n        const estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        const estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n      const getItemStyle = (rowIndex, columnIndex) => {\n        const { columnWidth, direction, rowHeight } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        const key = `${rowIndex},${columnIndex}`;\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          const [, left] = getColumnPosition(props, columnIndex, unref(cache));\n          const _cache = unref(cache);\n          const rtl = isRTL(direction);\n          const [height, top] = getRowPosition(props, rowIndex, _cache);\n          const [width] = getColumnPosition(props, columnIndex, _cache);\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : `${left}px`,\n            right: rtl ? `${left}px` : void 0,\n            top: `${top}px`,\n            height: `${height}px`,\n            width: `${width}px`\n          };\n          return itemStyleCache[key];\n        }\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      onMounted(() => {\n        if (!isClient)\n          return;\n        const { initScrollLeft, initScrollTop } = props;\n        const windowElement = unref(windowRef);\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n        emitEvents();\n      });\n      const onUpdated = () => {\n        const { direction } = props;\n        const { scrollLeft, scrollTop, updateRequested } = unref(states);\n        const windowElement = unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG: {\n                windowElement.scrollLeft = -scrollLeft;\n                break;\n              }\n              case RTL_OFFSET_POS_ASC: {\n                windowElement.scrollLeft = scrollLeft;\n                break;\n              }\n              default: {\n                const { clientWidth, scrollWidth } = windowElement;\n                windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      };\n      const { resetAfterColumnIndex, resetAfterRowIndex, resetAfter } = instance.proxy;\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        states,\n        resetAfterColumnIndex,\n        resetAfterRowIndex,\n        resetAfter\n      });\n      const renderScrollbars = () => {\n        const {\n          scrollbarAlwaysOn,\n          scrollbarStartGap,\n          scrollbarEndGap,\n          totalColumn,\n          totalRow\n        } = props;\n        const width = unref(parsedWidth);\n        const height = unref(parsedHeight);\n        const estimatedWidth = unref(estimatedTotalWidth);\n        const estimatedHeight = unref(estimatedTotalHeight);\n        const { scrollLeft, scrollTop } = unref(states);\n        const horizontalScrollbar = h(ScrollBar, {\n          ref: hScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e(\"horizontal\"),\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        const verticalScrollbar = h(ScrollBar, {\n          ref: vScrollbar,\n          alwaysOn: scrollbarAlwaysOn,\n          startGap: scrollbarStartGap,\n          endGap: scrollbarEndGap,\n          class: ns.e(\"vertical\"),\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar,\n          verticalScrollbar\n        };\n      };\n      const renderItems = () => {\n        var _a;\n        const [columnStart, columnEnd] = unref(columnsToRender);\n        const [rowStart, rowEnd] = unref(rowsToRender);\n        const { data, totalColumn, totalRow, useIsScrolling, itemKey } = props;\n        const children = [];\n        if (totalRow > 0 && totalColumn > 0) {\n          for (let row = rowStart; row <= rowEnd; row++) {\n            for (let column = columnStart; column <= columnEnd; column++) {\n              children.push((_a = slots.default) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data,\n                key: itemKey({ columnIndex: column, data, rowIndex: row }),\n                isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              }));\n            }\n          }\n        }\n        return children;\n      };\n      const renderInner = () => {\n        const Inner = resolveDynamicComponent(props.innerElement);\n        const children = renderItems();\n        return [\n          h(Inner, {\n            style: unref(innerStyle),\n            ref: innerRef\n          }, !isString(Inner) ? {\n            default: () => children\n          } : children)\n        ];\n      };\n      const renderWindow = () => {\n        const Container = resolveDynamicComponent(props.containerElement);\n        const { horizontalScrollbar, verticalScrollbar } = renderScrollbars();\n        const Inner = renderInner();\n        return h(\"div\", {\n          key: 0,\n          class: ns.e(\"wrapper\"),\n          role: props.role\n        }, [\n          h(Container, {\n            class: props.className,\n            style: unref(windowStyle),\n            onScroll,\n            onWheel,\n            ref: windowRef\n          }, !isString(Container) ? { default: () => Inner } : Inner),\n          horizontalScrollbar,\n          verticalScrollbar\n        ]);\n      };\n      return renderWindow;\n    }\n  });\n};\n\nexport { createGrid as default };\n//# sourceMappingURL=build-grid.mjs.map\n","import { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, onUpdated, resolveDynamicComponent, h } from 'vue';\nimport '../../../../utils/index.mjs';\nimport '../../../../hooks/index.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport useWheel from '../hooks/use-wheel.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { isHorizontal, getScrollDir, getRTLOffsetType } from '../utils.mjs';\nimport { virtualizedListProps } from '../props.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, BACKWARD, FORWARD, RTL, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, HORIZONTAL, RTL_OFFSET_POS_ASC } from '../defaults.mjs';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { isNumber } from '../../../../utils/types.mjs';\nimport { hasOwn, isString } from '@vue/shared';\nimport { isClient } from '@vueuse/core';\n\nconst createList = ({\n  name,\n  getOffset,\n  getItemSize,\n  getItemOffset,\n  getEstimatedTotalSize,\n  getStartIndexForOffset,\n  getStopIndexForStartIndex,\n  initCache,\n  clearCache,\n  validateProps\n}) => {\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup(props, { emit, expose }) {\n      validateProps(props);\n      const instance = getCurrentInstance();\n      const ns = useNamespace(\"vl\");\n      const dynamicSizeCache = ref(initCache(props, instance));\n      const getItemStyleCache = useCache();\n      const windowRef = ref();\n      const innerRef = ref();\n      const scrollbarRef = ref();\n      const states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn\n      });\n      const itemsToRender = computed(() => {\n        const { total, cache } = props;\n        const { isScrolling, scrollDir, scrollOffset } = unref(states);\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n        const startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));\n        const stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));\n        const cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        const cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [\n          Math.max(0, startIndex - cacheBackward),\n          Math.max(0, Math.min(total - 1, stopIndex + cacheForward)),\n          startIndex,\n          stopIndex\n        ];\n      });\n      const estimatedTotalSize = computed(() => getEstimatedTotalSize(props, unref(dynamicSizeCache)));\n      const _isHorizontal = computed(() => isHorizontal(props.layout));\n      const windowStyle = computed(() => [\n        {\n          position: \"relative\",\n          [`overflow-${_isHorizontal.value ? \"x\" : \"y\"}`]: \"scroll\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        },\n        {\n          direction: props.direction,\n          height: isNumber(props.height) ? `${props.height}px` : props.height,\n          width: isNumber(props.width) ? `${props.width}px` : props.width\n        },\n        props.style\n      ]);\n      const innerStyle = computed(() => {\n        const size = unref(estimatedTotalSize);\n        const horizontal = unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : `${size}px`,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? `${size}px` : \"100%\"\n        };\n      });\n      const clientSize = computed(() => _isHorizontal.value ? props.width : props.height);\n      const { onWheel } = useWheel({\n        atStartEdge: computed(() => states.value.scrollOffset <= 0),\n        atEndEdge: computed(() => states.value.scrollOffset >= estimatedTotalSize.value),\n        layout: computed(() => props.layout)\n      }, (offset) => {\n        var _a, _b;\n        ;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      });\n      const emitEvents = () => {\n        const { total } = props;\n        if (total > 0) {\n          const [cacheStart, cacheEnd, visibleStart, visibleEnd] = unref(itemsToRender);\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n        const { scrollDir, scrollOffset, updateRequested } = unref(states);\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n      const scrollVertically = (e) => {\n        const { clientHeight, scrollHeight, scrollTop } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n        const scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        };\n        nextTick(resetIsScrolling);\n      };\n      const scrollHorizontally = (e) => {\n        const { clientWidth, scrollLeft, scrollWidth } = e.currentTarget;\n        const _states = unref(states);\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n        const { direction } = props;\n        let scrollOffset = scrollLeft;\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG: {\n              scrollOffset = -scrollLeft;\n              break;\n            }\n            case RTL_OFFSET_POS_DESC: {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n              break;\n            }\n          }\n        }\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = {\n          ..._states,\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset,\n          updateRequested: false\n        };\n        nextTick(resetIsScrolling);\n      };\n      const onScroll = (e) => {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n      const onScrollbarScroll = (distanceToGo, totalSteps) => {\n        const offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n      const scrollTo = (offset) => {\n        offset = Math.max(offset, 0);\n        if (offset === unref(states).scrollOffset) {\n          return;\n        }\n        states.value = {\n          ...unref(states),\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true\n        };\n        nextTick(resetIsScrolling);\n      };\n      const scrollToItem = (idx, alignment = AUTO_ALIGNMENT) => {\n        const { scrollOffset } = unref(states);\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));\n      };\n      const getItemStyle = (idx) => {\n        const { direction, itemSize, layout } = props;\n        const itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        let style;\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          const offset = getItemOffset(props, idx, unref(dynamicSizeCache));\n          const size = getItemSize(props, idx, unref(dynamicSizeCache));\n          const horizontal = unref(_isHorizontal);\n          const isRtl = direction === RTL;\n          const offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : `${offsetHorizontal}px`,\n            right: isRtl ? `${offsetHorizontal}px` : void 0,\n            top: !horizontal ? `${offset}px` : 0,\n            height: !horizontal ? `${size}px` : \"100%\",\n            width: horizontal ? `${size}px` : \"100%\"\n          };\n        }\n        return style;\n      };\n      const resetIsScrolling = () => {\n        states.value.isScrolling = false;\n        nextTick(() => {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n      const resetScrollTop = () => {\n        const window = windowRef.value;\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n      onMounted(() => {\n        if (!isClient)\n          return;\n        const { initScrollOffset } = props;\n        const windowElement = unref(windowRef);\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n        emitEvents();\n      });\n      onUpdated(() => {\n        const { direction, layout } = props;\n        const { scrollOffset, updateRequested } = unref(states);\n        const windowElement = unref(windowRef);\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case RTL_OFFSET_NAG: {\n                  windowElement.scrollLeft = -scrollOffset;\n                  break;\n                }\n                case RTL_OFFSET_POS_ASC: {\n                  windowElement.scrollLeft = scrollOffset;\n                  break;\n                }\n                default: {\n                  const { clientWidth, scrollWidth } = windowElement;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                  break;\n                }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      const api = {\n        ns,\n        clientSize,\n        estimatedTotalSize,\n        windowStyle,\n        windowRef,\n        innerRef,\n        innerStyle,\n        itemsToRender,\n        scrollbarRef,\n        states,\n        getItemStyle,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop\n      };\n      expose({\n        windowRef,\n        innerRef,\n        getItemStyleCache,\n        scrollTo,\n        scrollToItem,\n        resetScrollTop,\n        states\n      });\n      return api;\n    },\n    render(ctx) {\n      var _a;\n      const {\n        $slots,\n        className,\n        clientSize,\n        containerElement,\n        data,\n        getItemStyle,\n        innerElement,\n        itemsToRender,\n        innerStyle,\n        layout,\n        total,\n        onScroll,\n        onScrollbarScroll,\n        onWheel,\n        states,\n        useIsScrolling,\n        windowStyle,\n        ns\n      } = ctx;\n      const [start, end] = itemsToRender;\n      const Container = resolveDynamicComponent(containerElement);\n      const Inner = resolveDynamicComponent(innerElement);\n      const children = [];\n      if (total > 0) {\n        for (let i = start; i <= end; i++) {\n          children.push((_a = $slots.default) == null ? void 0 : _a.call($slots, {\n            data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n      const InnerNode = [\n        h(Inner, {\n          style: innerStyle,\n          ref: \"innerRef\"\n        }, !isString(Inner) ? {\n          default: () => children\n        } : children)\n      ];\n      const scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize,\n        layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total\n      });\n      const listContainer = h(Container, {\n        class: [ns.e(\"window\"), className],\n        style: windowStyle,\n        onScroll,\n        onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? { default: () => [InnerNode] } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        class: [ns.e(\"wrapper\"), states.scrollbarAlwaysOn ? \"always-on\" : \"\"]\n      }, [listContainer, scrollbar]);\n    }\n  });\n};\n\nexport { createList as default };\n//# sourceMappingURL=build-list.mjs.map\n","import { isFunction } from '@vue/shared';\nimport '../../../../utils/index.mjs';\nimport createGrid from '../builders/build-grid.mjs';\nimport { SMART_ALIGNMENT, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, DEFAULT_DYNAMIC_LIST_ITEM_SIZE } from '../defaults.mjs';\nimport { isUndefined, isNumber } from '../../../../utils/types.mjs';\nimport { throwError } from '../../../../utils/error.mjs';\n\nconst { max, min, floor } = Math;\nconst SCOPE = \"ElDynamicSizeGrid\";\nconst ACCESS_SIZER_KEY_MAP = {\n  column: \"columnWidth\",\n  row: \"rowHeight\"\n};\nconst ACCESS_LAST_VISITED_KEY_MAP = {\n  column: \"lastVisitedColumnIndex\",\n  row: \"lastVisitedRowIndex\"\n};\nconst getItemFromCache = (props, index, gridCache, type) => {\n  const [cachedItems, sizer, lastVisited] = [\n    gridCache[type],\n    props[ACCESS_SIZER_KEY_MAP[type]],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  if (index > lastVisited) {\n    let offset = 0;\n    if (lastVisited >= 0) {\n      const item = cachedItems[lastVisited];\n      offset = item.offset + item.size;\n    }\n    for (let i = lastVisited + 1; i <= index; i++) {\n      const size = sizer(i);\n      cachedItems[i] = {\n        offset,\n        size\n      };\n      offset += size;\n    }\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]] = index;\n  }\n  return cachedItems[index];\n};\nconst bs = (props, gridCache, low, high, offset, type) => {\n  while (low <= high) {\n    const mid = low + floor((high - low) / 2);\n    const currentOffset = getItemFromCache(props, mid, gridCache, type).offset;\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  return max(0, low - 1);\n};\nconst es = (props, gridCache, idx, offset, type) => {\n  const total = type === \"column\" ? props.totalColumn : props.totalRow;\n  let exponent = 1;\n  while (idx < total && getItemFromCache(props, idx, gridCache, type).offset < offset) {\n    idx += exponent;\n    exponent *= 2;\n  }\n  return bs(props, gridCache, floor(idx / 2), min(idx, total - 1), offset, type);\n};\nconst findItem = (props, gridCache, offset, type) => {\n  const [cache, lastVisitedIndex] = [\n    gridCache[type],\n    gridCache[ACCESS_LAST_VISITED_KEY_MAP[type]]\n  ];\n  const lastVisitedItemOffset = lastVisitedIndex > 0 ? cache[lastVisitedIndex].offset : 0;\n  if (lastVisitedItemOffset >= offset) {\n    return bs(props, gridCache, 0, lastVisitedIndex, offset, type);\n  }\n  return es(props, gridCache, max(0, lastVisitedIndex), offset, type);\n};\nconst getEstimatedTotalHeight = ({ totalRow }, { estimatedRowHeight, lastVisitedRowIndex, row }) => {\n  let sizeOfVisitedRows = 0;\n  if (lastVisitedRowIndex >= totalRow) {\n    lastVisitedRowIndex = totalRow - 1;\n  }\n  if (lastVisitedRowIndex >= 0) {\n    const item = row[lastVisitedRowIndex];\n    sizeOfVisitedRows = item.offset + item.size;\n  }\n  const unvisitedItems = totalRow - lastVisitedRowIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedRowHeight;\n  return sizeOfVisitedRows + sizeOfUnvisitedItems;\n};\nconst getEstimatedTotalWidth = ({ totalColumn }, { column, estimatedColumnWidth, lastVisitedColumnIndex }) => {\n  let sizeOfVisitedColumns = 0;\n  if (lastVisitedColumnIndex > totalColumn) {\n    lastVisitedColumnIndex = totalColumn - 1;\n  }\n  if (lastVisitedColumnIndex >= 0) {\n    const item = column[lastVisitedColumnIndex];\n    sizeOfVisitedColumns = item.offset + item.size;\n  }\n  const unvisitedItems = totalColumn - lastVisitedColumnIndex - 1;\n  const sizeOfUnvisitedItems = unvisitedItems * estimatedColumnWidth;\n  return sizeOfVisitedColumns + sizeOfUnvisitedItems;\n};\nconst ACCESS_ESTIMATED_SIZE_KEY_MAP = {\n  column: getEstimatedTotalWidth,\n  row: getEstimatedTotalHeight\n};\nconst getOffset = (props, index, alignment, scrollOffset, cache, type, scrollBarWidth) => {\n  const [size, estimatedSizeAssociates] = [\n    type === \"row\" ? props.height : props.width,\n    ACCESS_ESTIMATED_SIZE_KEY_MAP[type]\n  ];\n  const item = getItemFromCache(props, index, cache, type);\n  const estimatedSize = estimatedSizeAssociates(props, cache);\n  const maxOffset = max(0, min(estimatedSize - size, item.offset));\n  const minOffset = max(0, item.offset - size + scrollBarWidth + item.size);\n  if (alignment === SMART_ALIGNMENT) {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      alignment = AUTO_ALIGNMENT;\n    } else {\n      alignment = CENTERED_ALIGNMENT;\n    }\n  }\n  switch (alignment) {\n    case START_ALIGNMENT: {\n      return maxOffset;\n    }\n    case END_ALIGNMENT: {\n      return minOffset;\n    }\n    case CENTERED_ALIGNMENT: {\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n    }\n    case AUTO_ALIGNMENT:\n    default: {\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n    }\n  }\n};\nconst DynamicSizeGrid = createGrid({\n  name: \"ElDynamicSizeGrid\",\n  getColumnPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"column\");\n    return [item.size, item.offset];\n  },\n  getRowPosition: (props, idx, cache) => {\n    const item = getItemFromCache(props, idx, cache, \"row\");\n    return [item.size, item.offset];\n  },\n  getColumnOffset: (props, columnIndex, alignment, scrollLeft, cache, scrollBarWidth) => getOffset(props, columnIndex, alignment, scrollLeft, cache, \"column\", scrollBarWidth),\n  getRowOffset: (props, rowIndex, alignment, scrollTop, cache, scrollBarWidth) => getOffset(props, rowIndex, alignment, scrollTop, cache, \"row\", scrollBarWidth),\n  getColumnStartIndexForOffset: (props, scrollLeft, cache) => findItem(props, cache, scrollLeft, \"column\"),\n  getColumnStopIndexForStartIndex: (props, startIndex, scrollLeft, cache) => {\n    const item = getItemFromCache(props, startIndex, cache, \"column\");\n    const maxOffset = scrollLeft + props.width;\n    let offset = item.offset + item.size;\n    let stopIndex = startIndex;\n    while (stopIndex < props.totalColumn - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, startIndex, cache, \"column\").size;\n    }\n    return stopIndex;\n  },\n  getEstimatedTotalHeight,\n  getEstimatedTotalWidth,\n  getRowStartIndexForOffset: (props, scrollTop, cache) => findItem(props, cache, scrollTop, \"row\"),\n  getRowStopIndexForStartIndex: (props, startIndex, scrollTop, cache) => {\n    const { totalRow, height } = props;\n    const item = getItemFromCache(props, startIndex, cache, \"row\");\n    const maxOffset = scrollTop + height;\n    let offset = item.size + item.offset;\n    let stopIndex = startIndex;\n    while (stopIndex < totalRow - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, cache, \"row\").size;\n    }\n    return stopIndex;\n  },\n  injectToInstance: (instance, cache) => {\n    const resetAfter = ({ columnIndex, rowIndex }, forceUpdate) => {\n      var _a, _b;\n      forceUpdate = isUndefined(forceUpdate) ? true : forceUpdate;\n      if (isNumber(columnIndex)) {\n        cache.value.lastVisitedColumnIndex = Math.min(cache.value.lastVisitedColumnIndex, columnIndex - 1);\n      }\n      if (isNumber(rowIndex)) {\n        cache.value.lastVisitedRowIndex = Math.min(cache.value.lastVisitedRowIndex, rowIndex - 1);\n      }\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache.value(-1, null, null);\n      if (forceUpdate)\n        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n    };\n    const resetAfterColumnIndex = (columnIndex, forceUpdate) => {\n      resetAfter({\n        columnIndex\n      }, forceUpdate);\n    };\n    const resetAfterRowIndex = (rowIndex, forceUpdate) => {\n      resetAfter({\n        rowIndex\n      }, forceUpdate);\n    };\n    Object.assign(instance.proxy, {\n      resetAfterColumnIndex,\n      resetAfterRowIndex,\n      resetAfter\n    });\n  },\n  initCache: ({\n    estimatedColumnWidth = DEFAULT_DYNAMIC_LIST_ITEM_SIZE,\n    estimatedRowHeight = DEFAULT_DYNAMIC_LIST_ITEM_SIZE\n  }) => {\n    const cache = {\n      column: {},\n      estimatedColumnWidth,\n      estimatedRowHeight,\n      lastVisitedColumnIndex: -1,\n      lastVisitedRowIndex: -1,\n      row: {}\n    };\n    return cache;\n  },\n  clearCache: false,\n  validateProps: ({ columnWidth, rowHeight }) => {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!isFunction(columnWidth)) {\n        throwError(SCOPE, `\n          \"columnWidth\" must be passed as function,\n            instead ${typeof columnWidth} was given.\n        `);\n      }\n      if (!isFunction(rowHeight)) {\n        throwError(SCOPE, `\n          \"rowHeight\" must be passed as function,\n            instead ${typeof rowHeight} was given.\n        `);\n      }\n    }\n  }\n});\n\nexport { DynamicSizeGrid as default };\n//# sourceMappingURL=dynamic-size-grid.mjs.map\n"],"names":["createGrid","name","clearCache","getColumnPosition","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getEstimatedTotalHeight","getEstimatedTotalWidth","getColumnOffset","getRowOffset","getRowPosition","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initCache","injectToInstance","validateProps","props","emits","setup","emit","expose","slots","ns","instance","cache","windowRef","hScrollbar","vScrollbar","innerRef","states","isScrolling","scrollLeft","initScrollLeft","scrollTop","initScrollTop","updateRequested","xAxisScrollDir","yAxisScrollDir","getItemStyleCache","parsedHeight","Number","parseInt","height","parsedWidth","width","columnsToRender","totalColumn","totalRow","columnCache","startIndex","stopIndex","cacheBackward","Math","max","cacheForward","min","rowsToRender","rowCache","estimatedTotalHeight","estimatedTotalWidth","windowStyle","_a","position","overflow","WebkitOverflowScrolling","willChange","direction","style","innerStyle","pointerEvents","emitEvents","columnCacheStart","columnCacheEnd","columnVisibleStart","columnVisibleEnd","rowCacheStart","rowCacheEnd","rowVisibleStart","rowVisibleEnd","onScroll","e","clientHeight","clientWidth","scrollHeight","scrollWidth","currentTarget","_states","_scrollLeft","value","resetIsScrolling","onUpdated","onVerticalScroll","distance","totalSteps","offset","scrollTo","onHorizontalScroll","onWheel","atXStartEdge","atXEndEdge","atYStartEdge","atYEndEdge","x","y","_b","_c","_d","onMouseUp","call","getItemStyle","rowIndex","columnIndex","columnWidth","rowHeight","itemStyleCache","key","left","_cache","rtl","top","right","windowElement","resetAfterColumnIndex","resetAfterRowIndex","resetAfter","proxy","scrollToItem","columnIdx","alignment","scrollBarWidth","namespace","estimatedHeight","estimatedWidth","renderInner","Inner","innerElement","children","columnStart","columnEnd","rowStart","rowEnd","data","useIsScrolling","itemKey","row","column","push","default","renderItems","h","ref","Container","containerElement","horizontalScrollbar","verticalScrollbar","scrollbarAlwaysOn","scrollbarStartGap","scrollbarEndGap","alwaysOn","startGap","endGap","class","clientSize","layout","ratio","scrollFrom","total","visible","renderScrollbars","role","className","createList","getOffset","getItemSize","getItemOffset","getEstimatedTotalSize","getStartIndexForOffset","getStopIndexForStartIndex","dynamicSizeCache","scrollbarRef","scrollDir","scrollOffset","initScrollOffset","isScrollbarDragging","itemsToRender","estimatedTotalSize","_isHorizontal","size","horizontal","atStartEdge","atEndEdge","cacheStart","cacheEnd","visibleStart","visibleEnd","idx","resetScrollTop","window","api","itemSize","String","isRtl","offsetHorizontal","scrollHorizontally","scrollVertically","onScrollbarScroll","distanceToGo","render","ctx","$slots","start","end","i","index","InnerNode","scrollbar","this","listContainer","floor","ACCESS_SIZER_KEY_MAP","ACCESS_LAST_VISITED_KEY_MAP","getItemFromCache","gridCache","type","cachedItems","sizer","lastVisited","item","bs","low","high","mid","currentOffset","findItem","lastVisitedIndex","exponent","es","estimatedRowHeight","lastVisitedRowIndex","sizeOfVisitedRows","estimatedColumnWidth","lastVisitedColumnIndex","sizeOfVisitedColumns","ACCESS_ESTIMATED_SIZE_KEY_MAP","estimatedSizeAssociates","estimatedSize","maxOffset","minOffset","round","DynamicSizeGrid","forceUpdate","exposed","$forceUpdate","Object","assign"],"sourceRoot":""}